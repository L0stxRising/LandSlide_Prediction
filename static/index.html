<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Landslide Prediction — Fixed + Auto-orbit</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{ --card-w:460px; }
  html,body{ height:100%; margin:0; background:#02020a; font-family:'Poppins',sans-serif; -webkit-font-smoothing:antialiased; }
  #ui-card{
    position:absolute; left:50%; top:20%; transform:translateX(-50%); width:var(--card-w);
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03));
    border-radius:16px; padding:22px; color:#fff; z-index:30;
    box-shadow:0 12px 40px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    border:1px solid rgba(255,255,255,0.06); backdrop-filter: blur(10px) saturate(120%);
    transition: transform .25s ease, box-shadow .25s ease;
  }
  #ui-card:hover{ transform:translateX(-50%) translateY(-3px); box-shadow:0 22px 60px rgba(0,0,0,0.7); }
  h1{ margin:0 0 12px 0; font-size:22px; font-weight:700;
     background: linear-gradient(90deg,#00ffae,#00bfff,#9b7cff); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
  .input-row{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-bottom:10px; }
  .field{ display:flex; flex-direction:column; }
  label{ font-size:13px; color:#cbd5e0; margin-bottom:6px; }
  input[type=number]{ padding:10px 12px; border-radius:8px; border:none; font-size:14px; color:#0b0b0b; background: linear-gradient(180deg,#ffffff,#f2f5f7); }
  .full{ grid-column:1/-1; display:flex; flex-direction:column; gap:6px; }
  button{ width:100%; padding:12px; border-radius:10px; border:none; font-weight:700; font-size:15px; background: linear-gradient(90deg,#00b894,#00cec9); color:#02111a; cursor:pointer; }
  button:hover{ transform:scale(1.02); }
  .loader{ width:28px; height:28px; border-radius:50%; border:4px solid rgba(255,255,255,0.3); border-top:4px solid #00cec9; display:none; margin-left:10px; }
  .result{ margin-top:12px; font-weight:700; font-size:16px; color:#fff; min-height:22px; }
  .error{ color:#ff7a7a; }
  /* keep canvas behind UI */
  canvas { position:fixed; left:0; top:0; z-index:5; display:block; }
</style>
</head>
<body>
  <div id="ui-card">
    <h1>Landslide Prediction</h1>
    <div class="input-row">
      <div class="field"><label for="num0">Temperature (°C)</label><input id="num0" type="number" placeholder="e.g. 4.5"></div>
      <div class="field"><label for="num1">Humidity (%)</label><input id="num1" type="number" placeholder="e.g. 78"></div>
      <div class="field"><label for="num2">Precipitation (mm)</label><input id="num2" type="number" placeholder="e.g. 12"></div>
      <div class="field"><label for="num3">Soil Moisture (%)</label><input id="num3" type="number" placeholder="e.g. 31"></div>
      <div class="field full"><label for="num4">Elevation (m)</label><input id="num4" type="number" placeholder="e.g. 1320"></div>
      <div class="field"><label for="num5">Slope (°)</label><input id="num5" type="number" placeholder="e.g. 35"></div>
      <div class="field"><label for="num6">Vegetation Cover (%)</label><input id="num6" type="number" placeholder="e.g. 20"></div>
    </div>
    <div style="display:flex; gap:10px; align-items:center;">
      <button id="predictBtn">Predict</button>
      <div class="loader" id="loader"></div>
    </div>
    <div class="result" id="result"></div>
  </div>

  <!-- optional overlay DOM element (not used for canvas) -->
  <div id="aurora-overlay" aria-hidden="true"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
  // ---------------- SETTINGS ----------------
  const API_URL = "https://landslide-prediction-fweq.onrender.com/predict";

  // ---------------- RENDERER ----------------
  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.autoClear = false; // we'll render main scene then aurora
  document.body.appendChild(renderer.domElement);
  renderer.domElement.style.zIndex = '5';

  // ---------------- MAIN SCENE ----------------
  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x000012, 12, 160);

  const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 18);
  camera.lookAt(0,0,0);

  const ambient = new THREE.AmbientLight(0xffffff, 0.75);
  const dir = new THREE.DirectionalLight(0xffffff, 1.05);
  dir.position.set(12, 28, 10);
  scene.add(ambient, dir);

  // ---------------- TERRAIN ----------------
  const terrainGeo = new THREE.PlaneGeometry(120, 120, 220, 220);
  terrainGeo.rotateX(-Math.PI/2);
  const pos = terrainGeo.attributes.position;
  for (let i=0;i<pos.count;i++){
    const x = pos.getX(i), z = pos.getZ(i);
    const y = Math.sin(x*0.22)*Math.cos(z*0.22)*2.6 + Math.sin(x*0.6)*0.8 + (Math.random()-0.5)*0.4;
    pos.setY(i, y);
  }
  terrainGeo.computeVertexNormals();
  let landslideActive = false; // <-- add this near other globals
  // store base positions to avoid cumulative changes
  const basePositions = new Float32Array(terrainGeo.attributes.position.array.length);
  basePositions.set(terrainGeo.attributes.position.array);

  // vertex colors (snow threshold)
  const colors = new Float32Array(pos.count * 3);
  const grass = new THREE.Color(0x2f5a16);
  const snowC = new THREE.Color(0xffffff);
  const dirt = new THREE.Color(0x5a3f2b);
  for (let i=0;i<pos.count;i++){
    const yv = pos.getY(i);
    let c;
    if (yv > 2.0) c = snowC;
    else if (yv > 0.6) c = grass;
    else c = dirt.clone().lerp(grass, 0.35);
    colors[i*3+0] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
  }
  terrainGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  const terrainMat = new THREE.MeshStandardMaterial({ vertexColors:true, roughness:1.0, metalness:0.04, flatShading:true });
  const terrain = new THREE.Mesh(terrainGeo, terrainMat);
  terrain.receiveShadow = true;
  scene.add(terrain);

  // ---------------- SNOW PARTICLES ----------------
  const snowCount = 600;
  const snowGeo = new THREE.BufferGeometry();
  const snowArr = new Float32Array(snowCount * 3);
  for (let i=0;i<snowCount;i++){
    snowArr[i*3+0] = (Math.random()-0.5) * 110;
    snowArr[i*3+1] = Math.random()*30 + 6;
    snowArr[i*3+2] = (Math.random()-0.5) * 110;
  }
  snowGeo.setAttribute('position', new THREE.BufferAttribute(snowArr, 3));
  const snowMat = new THREE.PointsMaterial({ color:0xffffff, size:0.13, transparent:true, opacity:0.92 });
  const snow = new THREE.Points(snowGeo, snowMat);
  scene.add(snow);

  // ---------------- AURORA SCENE (ORTHO QUAD) ----------------
  const auroraScene = new THREE.Scene();
  const auroraCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

  const auroraUniforms = {
    uTime: { value: 0.0 },
    uAmplitude: { value: 1.0 },
    uColorA: { value: new THREE.Color(0x5227ff) },
    uColorB: { value: new THREE.Color(0x7cff67) },
    uColorC: { value: new THREE.Color(0x5227ff) },
    uResolution: { value: new THREE.Vector2(innerWidth, innerHeight) },
    uBlend: { value: 0.5 }
  };

  const auroraVertex = `
    varying vec2 vUv;
    void main(){
      vUv = uv;
      gl_Position = vec4(position.xy, 0.0, 1.0);
    }
  `;
  const auroraFragment = `
    precision highp float;
    varying vec2 vUv;
    uniform float uTime;
    uniform float uAmplitude;
    uniform vec3 uColorA;
    uniform vec3 uColorB;
    uniform vec3 uColorC;
    uniform vec2 uResolution;
    uniform float uBlend;

    vec3 permute(vec3 x){ return mod(((x * 34.0) + 1.0) * x, 289.0); }

    float snoise(vec2 v){
      const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
      vec2 i = floor(v + dot(v, C.yy));
      vec2 x0 = v - i + dot(i, C.xx);
      vec2 i1 = (x0.x > x0.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
      vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1;
      i = mod(i, 289.0);
      vec3 p = permute( permute(i.y + vec3(0.0,i1.y,1.0)) + i.x + vec3(0.0,i1.x,1.0) );
      vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
      m = m*m; m = m*m;
      vec3 x = 2.0 * fract(p * C.www) - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;
      m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
      vec3 g;
      g.x  = a0.x * x0.x + h.x * x0.y;
      g.yz = a0.yz * x12.xz + h.yz * x12.yw;
      return 130.0 * dot(m, g);
    }

    vec3 colorRamp(float t){
      if (t < 0.5) return mix(uColorA, uColorB, smoothstep(0.0, 0.5, t*2.0));
      return mix(uColorB, uColorC, smoothstep(0.5, 1.0, (t-0.5)*2.0));
    }

    void main(){
      vec2 uv = vUv;
      float nx = uv.x * 2.0;
      float time = uTime * 0.001;
      float n1 = snoise(vec2(nx * 1.0 + time * 0.12, time * 0.2)) * 0.5;
      float n2 = snoise(vec2(nx * 2.2 - time * 0.08, time * 0.45)) * 0.25;
      float n3 = snoise(vec2(nx * 4.0 + time * 0.18, time * 0.9)) * 0.12;
      float height = (n1 + n2 + n3) * uAmplitude;
      height = exp(height);
      float band = (uv.y * 1.8 - height + 0.25);
      float intensity = clamp(band * 0.9, -1.0, 1.0);
      float midPoint = 0.28;
      float alpha = smoothstep(midPoint - uBlend*0.6, midPoint + uBlend*0.6, intensity);
      float verticalMask = smoothstep(0.95, 0.15, uv.y);
      vec3 c = colorRamp(uv.x + sin(time*0.6)*0.02);
      vec3 aur = c * intensity * 1.2;
      gl_FragColor = vec4(aur * alpha * verticalMask, alpha * verticalMask * 0.9);
    }
  `;

  const quadGeo = new THREE.PlaneGeometry(2, 2);
  const auroraMat = new THREE.ShaderMaterial({
    vertexShader: auroraVertex,
    fragmentShader: auroraFragment,
    transparent: true,
    depthTest: false,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: auroraUniforms
  });
  const quad = new THREE.Mesh(quadGeo, auroraMat);
  auroraScene.add(quad);

  // ---------------- CAMERA AUTO-ORBIT (cinematic) ----------------
  let orbit = { radius: 18, speed: 0.02, angle: 0.0, tilt: 0.18 };
  let orbitEnabled = true;
  // smooth start offset
  function updateCamera(dt){
    if(!orbitEnabled) return;
    orbit.angle += orbit.speed * dt;
    const x = Math.cos(orbit.angle) * orbit.radius;
    const z = Math.sin(orbit.angle) * orbit.radius;
    const bob = Math.sin(orbit.angle * 0.5) * 0.4;
    camera.position.set(x * 0.6, 6 + bob, z * 0.6 + 4); // keep camera closer in Z bias
    camera.lookAt(0,1.0,0);
  }

  // ---------------- RESIZE ----------------
  function onResize(){
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
    auroraUniforms.uResolution.value.set(innerWidth, innerHeight);
  }
  window.addEventListener('resize', onResize, { passive:true });

  // ---------------- ANIMATION LOOP ----------------
  const clock = new THREE.Clock();
  let last = 0;
  function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    const dt = t - last; last = t;

    // update aurora time
    auroraUniforms.uTime.value = t * 1000;

    // camera auto orbit (use dt in seconds scaled)
    updateCamera(dt);

    // subtle terrain rotation for parallax
    terrain.rotation.y += 0.00025;

    // snow update (operate on array directly)
    const sArr = snowGeo.attributes.position.array;
    for (let i=1;i<sArr.length;i+=3){
      sArr[i] -= 0.04;
      if (sArr[i] < 0) sArr[i] = 30 + Math.random()*5;
    }
    snowGeo.attributes.position.needsUpdate = true;

    // landslide shake = set vertex position to base + offset (no accumulation)
    if (landslideActive){
      const pArr = terrainGeo.attributes.position.array;
      const amplitude = 0.04;
      for (let i=0;i<pArr.length;i+=3){
        const baseY = basePositions[i+1];
        const offset = Math.sin(t*25.0 + i*0.001) * amplitude;
        pArr[i+1] = baseY + offset;
      }
      terrainGeo.attributes.position.needsUpdate = true;
    } else {
      // ensure terrain returns to base if previously shaken
      const pArr = terrainGeo.attributes.position.array;
      let dirty = false;
      for (let i=0;i<pArr.length;i++){
        if (pArr[i] !== basePositions[i]) { dirty = true; break; }
      }
      if (dirty){
        terrainGeo.attributes.position.array.set(basePositions);
        terrainGeo.attributes.position.needsUpdate = true;
      }
    }

    // render main, then overlay aurora
    renderer.clear();
    renderer.render(scene, camera);
    renderer.render(auroraScene, auroraCamera);
  }
  animate();

  // ---------------- UI & PREDICTION ----------------
  const loader = document.getElementById('loader');
  const resultEl = document.getElementById('result');
  const predictBtn = document.getElementById('predictBtn');

  async function predict(){
    const values = [];
    for (let i=0;i<7;i++) values.push(parseFloat(document.getElementById('num'+i).value) || 0);
    loader.style.display = 'inline-block';
    resultEl.textContent = '';
    try{
      const res = await fetch(API_URL, {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ numbers: values })
      });
      const data = await res.json();
      loader.style.display = 'none';
      if (data.prediction){
        resultEl.classList.remove('error');
        resultEl.textContent = 'Prediction: ' + data.prediction;
        const map = { "Low":0x3cb371, "Moderate":0xffd700, "High":0xff8c00, "Very High":0xff0000 };
        terrain.material.color.setHex(map[data.prediction] || 0x3a5f0b);
        if (data.prediction === 'High' || data.prediction === 'Very High'){
          landslideActive = true;
          // amplify aurora temporarily
          auroraUniforms.uAmplitude.value = 1.6;
          auroraUniforms.uColorA.value.setHex(0x2fe0a3);
          auroraUniforms.uColorB.value.setHex(0x7cff67);
          auroraUniforms.uColorC.value.setHex(0x7752ff);
          setTimeout(()=>{ landslideActive = false; auroraUniforms.uAmplitude.value = 2.0; }, 4200);
        }
      } else {
        resultEl.classList.add('error');
        resultEl.textContent = data.error || 'Unexpected response';
      }
    } catch (err){
      loader.style.display = 'none';
      resultEl.classList.add('error');
      resultEl.textContent = 'Error: ' + err;
    }
  }

  predictBtn.addEventListener('click', predict);

  // small accessibility: ensure canvas is behind UI
  renderer.domElement.style.pointerEvents = 'auto';

  // expose toggle for orbit via console if needed
  window.toggleOrbit = (v) => { orbitEnabled = !!v; };

  </script>
</body>
</html>


