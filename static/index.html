<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Landslide Prediction 3D</title>
<style>
    body { margin:0; overflow:hidden; font-family:'Segoe UI',sans-serif; background:#1b1b1b; }
    #ui-card { 
        position:absolute; top:20px; left:50%; transform:translateX(-50%); 
        background: rgba(255,255,255,0.93); padding:20px; border-radius:15px; 
        box-shadow:0 8px 25px rgba(0,0,0,0.4); width:380px; text-align:center;
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }
    #ui-card:hover { transform:translateX(-50%) scale(1.03); box-shadow:0 10px 30px rgba(0,0,0,0.5); }
    #ui-card h1 { margin:0 0 10px 0; color:#333; font-size:22px; letter-spacing:0.5px; }
    #ui-card input {
        width:65px; margin:5px; padding:8px;
        border-radius:6px; border:1px solid #aaa;
        text-align:center; font-size:15px;
    }
    #ui-card button {
        padding:10px 20px; border:none; border-radius:8px;
        background:#2e8b57; color:white; font-weight:bold;
        cursor:pointer; transition:0.2s;
        margin-top:10px;
    }
    #ui-card button:hover { background:#3cb371; transform:scale(1.05); }
    #ui-card .result { margin-top:15px; font-size:18px; font-weight:bold; color:#222; min-height:24px; }
    .error { color:#d9534f; font-weight:600; }
    .loader {
        border:4px solid #f3f3f3; border-top:4px solid #2e8b57;
        border-radius:50%; width:30px; height:30px;
        animation: spin 1s linear infinite;
        margin:15px auto; display:none;
    }
    @keyframes spin { 100% { transform:rotate(360deg); } }
</style>
</head>
<body>

<div id="ui-card">
    <h1>Landslide Prediction</h1>
    <div id="inputs">
        <input type="number" id="num0" placeholder="0">
        <input type="number" id="num1" placeholder="0">
        <input type="number" id="num2" placeholder="0">
        <input type="number" id="num3" placeholder="0">
        <input type="number" id="num4" placeholder="0">
    </div>
    <button onclick="predict()">Predict</button>
    <div class="loader" id="loader"></div>
    <div class="result" id="result"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
const API_URL = "https://landslide-prediction-fweq.onrender.com/predict";

// === Scene Setup ===
let scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x1b1b1b, 10, 60);

let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 10);
camera.lookAt(0, 0, 0);

let renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x1b1b1b);
document.body.appendChild(renderer.domElement);

// Lights
const ambient = new THREE.AmbientLight(0xffffff, 0.7);
const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
dirLight.position.set(5, 10, 7);
scene.add(ambient, dirLight);

// === Terrain with Grass + Snow Gradient ===
const terrainGeo = new THREE.PlaneGeometry(25, 25, 100, 100);
terrainGeo.rotateX(-Math.PI / 2);

for (let i = 0; i < terrainGeo.attributes.position.count; i++) {
    const x = terrainGeo.attributes.position.getX(i);
    const z = terrainGeo.attributes.position.getZ(i);
    const y = Math.sin(x * 0.3) * Math.cos(z * 0.3) * 1.2 
            + Math.sin(x * 0.7) * 0.5 
            + (Math.random() - 0.5) * 0.2;
    terrainGeo.attributes.position.setY(i, y);
}
terrainGeo.computeVertexNormals();

const colors = [];
const grass = new THREE.Color(0x3a5f0b);
const snow = new THREE.Color(0xffffff);
const dirt = new THREE.Color(0x4e3c27);

for (let i = 0; i < terrainGeo.attributes.position.count; i++) {
    const y = terrainGeo.attributes.position.getY(i);
    let blended;
    if (y > 1.2) blended = snow.clone().lerp(grass, 0.4);
    else if (y > 0.3) blended = grass.clone();
    else blended = dirt.clone().lerp(grass, 0.5);
    colors.push(blended.r, blended.g, blended.b);
}
terrainGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

const terrainMat = new THREE.MeshStandardMaterial({
    vertexColors: true,
    roughness: 1,
    metalness: 0.05,
    flatShading: true
});
const terrain = new THREE.Mesh(terrainGeo, terrainMat);
scene.add(terrain);

// === Simple Road (gray strip) ===
const roadGeo = new THREE.PlaneGeometry(25, 2, 1, 1);
roadGeo.rotateX(-Math.PI / 2);
const roadMat = new THREE.MeshStandardMaterial({
    color: 0x3b3b3b,
    roughness: 0.9,
    metalness: 0.2
});
const road = new THREE.Mesh(roadGeo, roadMat);
road.position.y = 0.01;
road.rotation.y = 0.15;
scene.add(road);

// === Gradient Particles ===
const particleGeo = new THREE.BufferGeometry();
const particleCount = 350;
const positions = [];
const pColors = [];
const c1 = new THREE.Color(0xff69b4);
const c2 = new THREE.Color(0xffa500);
const c3 = new THREE.Color(0x9370db);

for (let i = 0; i < particleCount; i++) {
    positions.push((Math.random() - 0.5) * 40, Math.random() * 7 + 1, (Math.random() - 0.5) * 40);
    const c = c1.clone().lerp(c2, Math.random() * 0.5).lerp(c3, Math.random() * 0.5);
    pColors.push(c.r, c.g, c.b);
}
particleGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
particleGeo.setAttribute('color', new THREE.Float32BufferAttribute(pColors, 3));
const particleMat = new THREE.PointsMaterial({ size: 0.15, vertexColors: true, transparent: true, opacity: 0.85 });
const particles = new THREE.Points(particleGeo, particleMat);
scene.add(particles);

// === Animate ===
function animate() {
    requestAnimationFrame(animate);
    terrain.rotation.y += 0.0003;
    road.rotation.y += 0.0003;
    particles.rotation.y += 0.0005;

    const pos = particleGeo.attributes.position.array;
    for (let i = 1; i < pos.length; i += 3) {
        pos[i] += Math.sin(Date.now() * 0.0003 + i) * 0.0006;
    }
    particleGeo.attributes.position.needsUpdate = true;

    renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// === Prediction ===
async function predict() {
    const nums = [];
    for (let i = 0; i < 5; i++) nums.push(parseFloat(document.getElementById("num" + i).value) || 0);
    const loader = document.getElementById("loader");
    const result = document.getElementById("result");
    loader.style.display = "block"; result.textContent = "";

    try {
        const res = await fetch(API_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ numbers: nums })
        });
        const data = await res.json();
        loader.style.display = "none";

        if (data.prediction) {
            result.classList.remove("error");
            result.textContent = `Prediction: ${data.prediction}`;
            const colorMap = { "Low": 0x3cb371, "Moderate": 0xffd700, "High": 0xff8c00, "Very High": 0xff0000 };
            terrain.material.color.setHex(colorMap[data.prediction] || 0x3a5f0b);
        } else if (data.error) {
            result.classList.add("error");
            result.textContent = `Error: ${data.error}`;
        } else {
            result.classList.add("error");
            result.textContent = "Error: Unexpected response format";
        }
    } catch (err) {
        loader.style.display = "none";
        result.classList.add("error");
        result.textContent = `Error: ${err}`;
    }
}
</script>
</body>
</html>
